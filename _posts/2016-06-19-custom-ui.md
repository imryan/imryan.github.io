---
layout: post
title: Custom UIButton with Delegate 
---

You're designing a project and you decide it would be more efficient to use custom interface elements. In this example you'd need a button that, when pressed, changes some values and performs various behaviors. Instead of creating an empty `NSObject` class and constructing a button object, you can simply create a new class that subclasses `UIButton`. By doing so, you're already incorporating the attributes and behaviors of a regular `UIButton`, except you can name this button whatever you'd like, add extra attributes, actions, etc. Just make sure you feed it and take care of it.

We'll be creating a custom button subclass that is initialized with a string value that will be displayed on the button's text label. When the button is pressed, we will perform a simple action such as changing a text label to showcase the behaviors of our button class in other classes. The subclass will contain delegate methods that can be accessed by any outside class that will allow it to interact with the button through its delegate.

First off, we'll create a new subclass of `UIButton` called `RCButton` and give it an initializer to pass in some values I need to construct the button. Feel free to change the prefix to your own initials. Keep in mind also that Apple does suggest using a three character prefix, but in this case I will use two.

```
@interface RCButton : UIButton

@property (nonatomic, readonly) UILabel *textLabel;

- (instancetype)initWithFrame:(CGRect)frame text:(NSString *)text;

@end
```
And then we dip into the implementation to assign values and setup our subviews.

```
@interface  RCButton ()

@property (nonatomic, readwrite) UILabel *textLabel;

@end

@implementation RCButton

#pragma mark - Initializer

- (instancetype)initWithFrame:(CGRect)frame text:(NSString *)text {
    self = [super initWithFrame:CGRectMake(frame.origin.x, frame.origin.y, 50.f, 50.f)];
    
    if (self) {
        _textLabel = [[UILabel alloc] initWithFrame:CGRectMake(frame.origin.x, frame.origin.y, 65.f, 20.f)];
        _textLabel.font = [UIFont fontWithName:@"Helvetica-Neue" size:11.5f];
        _textLabel.textColor = [UIColor grayColor];
        _textLabel.center = self.center;
        _textLabel.text = text;
        _textLabel.textAlignment = NSTextAlignmentCenter;
        
        [self addSubview:_textLabel];
        [self addTarget:self action:@selector(buttonWasSelected:) forControlEvents:UIControlEventTouchUpInside];
    }
    
    return self;
}

#pragma mark - Draw Rect

- (void)drawRect:(CGRect)rect {
    [self setImage:[UIImage imageNamed:@"circle"] forState:UIControlStateNormal];
    [self setImage:[UIImage imageNamed:@"circle-selected"] forState:UIControlStateHighlighted];
}
```
In our initializer we setup our view to take the frame of the class's view that is instantiating the button and then setup the `UILabel` which will be displayed in the center of the button serving as its title label. The call to `addTarget:` links the button with its action, the selector, that will be passed in as a sender argument (the button itself).

What we have so far should appear as the screenshot below. Given that we have two `@3x` images named `circle` and `circle-selected`.

![]({{ site.url }}/assets/img/flatiron/circle.png)

And when the button is selected by our user...

![]({{ site.url }}/assets/img/flatiron/circle-selected.png)

Now it's time to add some functionality. We'll start by creating our own delegate for our custom button. All we need to do is make a few additions in our button's header file like so.

```
@class RCButton;

@protocol RCButtonDelegate <NSObject>

- (void)buttonWasSelected:(RCButton *)button;

@end

@interface RCButton : UIButton <RCButtonDelegate>

@property (nonatomic, readonly) UILabel *textLabel;
@property (nonatomic, weak) id<RCButtonDelegate> delegate;

- (instancetype)initWithFrame:(CGRect)frame text:(NSString *)text;

@end
```
We reference the current class through `@class` so that we may access the `RCButton` argument in the `buttonWasSelected:` method since our delegate is declared above our interface. To make use of this delegate, we need to write out the method bodies for our delegate functions.

```
#pragma mark - Delegate

- (void)buttonWasSelected:(RCButton *)button {
    [self.delegate buttonWasSelected:button];
}
```
We pass the `RCButton` argument to the delegate's method which will be sent to the class that conforms to our delegate. Let's implement our delegate methods in a separate view controller class where we create an instance of our button.

```
#import <UIKit/UIKit.h>
#import "RCButton.h"

@interface ViewController : UIViewController <RCButtonDelegate>

@end
```

```
@interface ViewController ()

@property (nonatomic, strong) IBOutlet UILabel *label;
@property (nonatomic, assign) NSUInteger counter;

@end

@implementation ViewController

#pragma mark - RCButtonDelegate

- (void)buttonWasSelected:(RCButton *)button {
    self.label.text = [NSString stringWithFormat:@"Pressed '%@' %lu times!", button.textLabel.text, self.counter++];
}

#pragma mark - View

- (void)viewDidLoad {
    [super viewDidLoad];
    
    RCButton *button = [[RCButton alloc] initWithFrame:self.view.frame text:@"Hello"];
    button.center = self.view.center;
    button.delegate = self;
    
    [self.view addSubview:button];
}
```
Nice and simple. Here's what our UI looks like now after we add a `UILabel` to the view in order to capture the amount of button presses in a formatted string.

![]({{ site.url }}/assets/img/flatiron/view.png)

When we press our custom button, the selector that was declared in the custom class is called which then passes the method call to the delegate, then the delegate to us. We now have access to any public property on the `RCButton` argument.